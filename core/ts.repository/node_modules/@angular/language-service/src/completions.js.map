{"version":3,"file":"completions.js","sourceRoot":"","sources":["../../../../modules/@angular/language-service/src/completions.ts"],"names":[],"mappings":"AAAA;;;;;;GAMG;;;;;;OAEI,EAAM,gBAAgB,EAAE,SAAS,EAAE,YAAY,EAAC,MAAM,6CAA6C;OACnG,EAAY,OAAO,EAAmB,IAAI,EAAC,MAAM,qCAAqC;OACtF,EAAC,oBAAoB,EAAC,MAAM,2CAA2C;OACvE,EAAC,cAAc,EAAE,cAAc,EAAE,WAAW,EAAC,MAAM,sCAAsC;OACzF,EAAC,WAAW,EAAE,eAAe,EAAC,MAAM,gCAAgC;OAIpE,EAAC,wBAAwB,EAAE,kBAAkB,EAAC,MAAM,eAAe;OACnE,EAAC,cAAc,EAAE,YAAY,EAAE,UAAU,EAAE,aAAa,EAAC,MAAM,aAAa;OAC5E,EAAC,WAAW,EAAC,MAAM,aAAa;OAChC,EAAC,mBAAmB,EAA2B,eAAe,EAAC,MAAM,iBAAiB;OAEtF,EAAC,OAAO,EAAE,YAAY,EAAE,oBAAoB,EAAE,MAAM,EAAE,YAAY,EAAE,MAAM,EAAE,YAAY,EAAC,MAAM,SAAS;AAE/G,IAAM,oBAAoB,GAAG,GAAG,CAAC;AAEjC,IAAM,kBAAkB,GAAG;IACzB,IAAI,EAAE,IAAI;IACV,MAAM,EAAE,IAAI;IACZ,QAAQ,EAAE,IAAI;IACd,IAAI,EAAE,IAAI;IACV,IAAI,EAAE,IAAI;IACV,KAAK,EAAE,IAAI;IACX,IAAI,EAAE,IAAI;IACV,IAAI,EAAE,IAAI;CACX,CAAC;AAEF,uCAAuC,YAA0B;IAC/D,IAAI,MAAM,GAAgB,SAAS,CAAC;IAC/B,kCAAO,EAAE,sCAAW,EAAE,gCAAQ,CAAiB;IACpD,6EAA6E;IAC7E,IAAI,gBAAgB,GAAG,YAAY,CAAC,QAAQ,GAAG,QAAQ,CAAC,IAAI,CAAC,KAAK,CAAC;IACnE,IAAI,IAAI,GAAG,IAAI,WAAW,CAAC,OAAO,EAAE,gBAAgB,CAAC,CAAC;IACtD,IAAI,YAAY,GAAG,IAAI,CAAC,IAAI,CAAC;IAC7B,EAAE,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC;QACf,MAAM,GAAG,kBAAkB,CAAC,YAAY,EAAE,IAAI,CAAC,CAAC;IAClD,CAAC;IAAC,IAAI,CAAC,CAAC;QACN,IAAI,aAAW,GAAG,gBAAgB,GAAG,YAAY,CAAC,UAAU,CAAC,KAAK,CAAC,MAAM,CAAC;QAC1E,YAAY,CAAC,KAAK,CACd;YACE,YAAY,YAAC,GAAG;gBACd,IAAI,YAAY,GAAG,MAAM,CAAC,GAAG,CAAC,UAAU,CAAC,CAAC;gBAC1C,IAAI,MAAM,GAAG,GAAG,CAAC,IAAI,CAAC,MAAM,CAAC;gBAC7B,EAAE,CAAC,CAAC,gBAAgB;oBAChB,YAAY,CAAC,KAAK,GAAG,MAAM,GAAG,CAAC,CAAC,qCAAqC,CAAC,CAAC,CAAC;oBAC1E,4DAA4D;oBAC5D,MAAM,GAAG,kBAAkB,CAAC,YAAY,EAAE,IAAI,CAAC,CAAC;gBAClD,CAAC;gBAAC,IAAI,CAAC,EAAE,CAAC,CAAC,gBAAgB,GAAG,YAAY,CAAC,GAAG,CAAC,CAAC,CAAC;oBAC/C,4EAA4E;oBAC5E,oCAAoC;oBACpC,MAAM,GAAG,oBAAoB,CAAC,YAAY,EAAE,IAAI,CAAC,CAAC;gBACpD,CAAC;YACH,CAAC;YACD,cAAc,YAAC,GAAG;gBAChB,EAAE,CAAC,CAAC,CAAC,GAAG,CAAC,SAAS,IAAI,CAAC,MAAM,CAAC,gBAAgB,EAAE,MAAM,CAAC,GAAG,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,CAAC;oBACvE,kEAAkE;oBAClE,MAAM,GAAG,oBAAoB,CAAC,YAAY,EAAE,IAAI,CAAC,CAAC;gBACpD,CAAC;gBAAC,IAAI,CAAC,EAAE,CAAC,CAAC,GAAG,CAAC,SAAS,IAAI,MAAM,CAAC,gBAAgB,EAAE,MAAM,CAAC,GAAG,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,CAAC;oBAC5E,MAAM,GAAG,yBAAyB,CAAC,YAAY,EAAE,gBAAgB,EAAE,GAAG,CAAC,CAAC;gBAC1E,CAAC;YACH,CAAC;YACD,SAAS,YAAC,GAAG;gBACX,+BAA+B;gBAC/B,MAAM,GAAG,iBAAiB,CAAC,aAAa,CAAC,QAAQ,EAAE,MAAM,CAAC,GAAG,CAAC,CAAC,EAAE,aAAW,CAAC,CAAC;gBAC9E,EAAE,CAAC,CAAC,MAAM,CAAC;oBAAC,MAAM,CAAC,MAAM,CAAC;gBAC1B,MAAM,GAAG,wBAAwB,CAAC,YAAY,EAAE,gBAAgB,CAAC,CAAC;gBAClE,EAAE,CAAC,CAAC,MAAM,CAAC;oBAAC,MAAM,CAAC,MAAM,CAAC;gBAC1B,IAAI,OAAO,GAAG,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC;gBAClC,EAAE,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC;oBACZ,IAAI,UAAU,GAAG,oBAAoB,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC;oBACpD,EAAE,CAAC,CAAC,UAAU,CAAC,WAAW,KAAK,cAAc,CAAC,aAAa,CAAC,CAAC,CAAC;wBAC5D,MAAM,GAAG,+BAA+B,CAAC,YAAY,EAAE,IAAI,CAAC,CAAC;wBAC7D,EAAE,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC;4BACZ,4DAA4D;4BAC5D,MAAM,GAAG,kBAAkB,CAAC,YAAY,EAAE,IAAI,CAAC,CAAC;wBAClD,CAAC;oBACH,CAAC;gBACH,CAAC;gBAAC,IAAI,CAAC,CAAC;oBACN,mEAAmE;oBACnE,MAAM,GAAG,+BAA+B,CAAC,YAAY,EAAE,IAAI,CAAC,CAAC;oBAC7D,EAAE,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC;wBACZ,MAAM,GAAG,kBAAkB,CAAC,YAAY,EAAE,IAAI,CAAC,CAAC;oBAClD,CAAC;gBACH,CAAC;YACH,CAAC;YACD,YAAY,YAAC,GAAG,IAAG,CAAC;YACpB,cAAc,YAAC,GAAG,IAAG,CAAC;YACtB,kBAAkB,YAAC,GAAG,IAAG,CAAC;SAC3B,EACD,IAAI,CAAC,CAAC;IACZ,CAAC;IACD,MAAM,CAAC,MAAM,CAAC;AAChB,CAAC;AAED,8BAA8B,IAAkB,EAAE,IAAiB;IACjE,IAAI,IAAI,GAAG,IAAI,CAAC,IAAI,YAAY,OAAO,GAAG,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;IAC/E,EAAE,CAAC,CAAC,IAAI,YAAY,OAAO,CAAC,CAAC,CAAC;QAC5B,MAAM,CAAC,8BAA8B,CAAC,IAAI,EAAE,IAAI,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC;IAC/D,CAAC;IACD,MAAM,CAAC,SAAS,CAAC;AACnB,CAAC;AAED,wCACI,IAAkB,EAAE,WAAmB,EAAE,OAAiB;IAC5D,IAAM,UAAU,GAAG,2BAA2B,CAAC,IAAI,EAAE,WAAW,EAAE,OAAO,CAAC,CAAC;IAE3E,yCAAyC;IACzC,MAAM,CAAC,UAAU,CAAC,GAAG,CAAa,UAAA,IAAI,IAAI,OAAA,CAAC;QACP,IAAI,EAAE,IAAI,CAAC,QAAQ,GAAG,gBAAgB,GAAG,WAAW;QACpD,IAAI,EAAE,UAAU,CAAC,IAAI,CAAC;QACtB,IAAI,EAAE,IAAI,CAAC,IAAI;KAChB,CAAC,EAJM,CAIN,CAAC,CAAC;AACxC,CAAC;AAED,qCACI,IAAkB,EAAE,WAAmB,EAAE,OAAiB;IAC5D,IAAI,UAAU,GAAe,EAAE,CAAC;IAEhC,sBAAsB;IACtB,IAAI,cAAc,GAAG,cAAc,CAAC,WAAW,CAAC,IAAI,EAAE,CAAC;IACvD,EAAE,CAAC,CAAC,cAAc,CAAC,CAAC,CAAC;QACnB,UAAU,CAAC,IAAI,OAAf,UAAU,EAAS,cAAc,CAAC,GAAG,CAAW,UAAA,IAAI,IAAI,OAAA,CAAC,EAAC,UAAI,EAAE,QAAQ,EAAE,IAAI,EAAC,CAAC,EAAxB,CAAwB,CAAC,CAAC,CAAC;IACrF,CAAC;IAED,sBAAsB;IACtB,IAAI,cAAc,GAAG,aAAa,CAAC,WAAW,CAAC,CAAC;IAChD,EAAE,CAAC,CAAC,cAAc,CAAC,CAAC,CAAC;QACnB,UAAU,CAAC,IAAI,OAAf,UAAU,EAAS,cAAc,CAAC,GAAG,CAAW,UAAA,IAAI,IAAI,OAAA,CAAC,EAAC,UAAI,EAAE,KAAK,EAAE,IAAI,EAAC,CAAC,EAArB,CAAqB,CAAC,CAAC,CAAC;IAClF,CAAC;IAED,kBAAkB;IAClB,IAAI,UAAU,GAAG,UAAU,CAAC,WAAW,CAAC,CAAC;IACzC,EAAE,CAAC,CAAC,UAAU,CAAC,CAAC,CAAC;QACf,UAAU,CAAC,IAAI,OAAf,UAAU,EAAS,UAAU,CAAC,GAAG,CAAW,UAAA,IAAI,IAAI,OAAA,CAAC,EAAC,UAAI,EAAE,MAAM,EAAE,IAAI,EAAC,CAAC,EAAtB,CAAsB,CAAC,CAAC,CAAC;IAC/E,CAAC;IAED,IAAA,uBAAsD,EAAjD,wBAAS,EAAE,oBAAgB,CAAuB;IACvD,EAAE,CAAC,CAAC,SAAS,IAAI,SAAS,CAAC,MAAM,CAAC,CAAC,CAAC;QAClC,0DAA0D;QAC1D,IAAM,mBAAmB,GACrB,SAAS,CAAC,MAAM,CAAC,UAAA,QAAQ,IAAI,OAAA,CAAC,QAAQ,CAAC,OAAO,IAAI,QAAQ,CAAC,OAAO,IAAI,WAAW,EAApD,CAAoD,CAAC,CAAC;QACvF,IAAM,yBAAyB,GAC3B,mBAAmB,CAAC,GAAG,CAAC,UAAA,QAAQ,IAAI,OAAA,CAAC,EAAC,kBAAQ,EAAE,KAAK,EAAE,QAAQ,CAAC,KAAK,CAAC,MAAM,CAAC,UAAA,CAAC,IAAI,OAAA,CAAC,CAAC,CAAC,EAAH,CAAG,CAAC,EAAC,CAAC,EAApD,CAAoD,CAAC,CAAC;QAC9F,IAAI,OAAK,GAAG,OAAO,CAAC,yBAAyB,CAAC,GAAG,CAAa,UAAA,eAAe;YAC3E,IAAM,SAAS,GAAG,WAAW,CAAC,GAAG,CAAC,eAAe,CAAC,QAAQ,CAAC,CAAC;YAC5D,IAAM,MAAM,GAAG,eAAe,CAAC,KAAK,CAAC,GAAG,CACpC,UAAA,IAAI,IAAI,OAAA,CAAC,EAAC,UAAI,EAAE,KAAK,EAAE,IAAI,IAAI,SAAS,CAAC,MAAM,EAAE,MAAM,EAAE,IAAI,IAAI,SAAS,CAAC,OAAO,EAAC,CAAC,EAA5E,CAA4E,CAAC,CAAC;YAC1F,MAAM,CAAC,MAAM,CAAC;QAChB,CAAC,CAAC,CAAC,CAAC;QAEJ,sEAAsE;QACtE,yBAAyB,CAAC,OAAO,CAAC,UAAA,eAAe;YAC/C,IAAM,QAAQ,GAAG,eAAe,CAAC,QAAQ,CAAC;YAC1C,IAAM,SAAS,GAAG,WAAW,CAAC,GAAG,CAAC,QAAQ,CAAC,CAAC;YAC5C,EAAE,CAAC,CAAC,SAAS,IAAI,oBAAoB,CAAC,SAAS,CAAC,IAAI,CAAC,IAAI,QAAQ,CAAC,KAAK,CAAC,MAAM;gBAC1E,QAAQ,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;gBACtB,OAAK,CAAC,IAAI,CAAC,EAAC,IAAI,EAAE,QAAQ,CAAC,KAAK,CAAC,CAAC,CAAC,EAAE,QAAQ,EAAE,IAAI,EAAC,CAAC,CAAC;YACxD,CAAC;QACH,CAAC,CAAC,CAAC;QAEH,8EAA8E;QAC9E,IAAI,eAAe,GAAG,OAAO;YACzB,wBAAwB,CAAC,OAAO,CAAC;YACjC,wBAAwB,CAAC,IAAI,OAAO,CAAC,WAAW,EAAE,EAAE,EAAE,EAAE,EAAE,SAAS,EAAE,SAAS,EAAE,SAAS,CAAC,CAAC,CAAC;QAEhG,IAAI,OAAO,GAAG,IAAI,eAAe,EAAE,CAAC;QACpC,OAAO,CAAC,cAAc,CAAC,SAAS,CAAC,CAAC;QAClC,OAAO,CAAC,KAAK,CAAC,eAAe,EAAE,UAAA,QAAQ;YACrC,IAAI,SAAS,GAAG,WAAW,CAAC,GAAG,CAAC,QAAQ,CAAC,CAAC;YAC1C,EAAE,CAAC,CAAC,SAAS,CAAC,CAAC,CAAC;gBACd,OAAK,CAAC,IAAI,OAAV,OAAK,EAAS,MAAM,CAAC,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,CAAC,GAAG,CAAC,UAAA,IAAI,IAAI,OAAA,CAAC,EAAC,UAAI,EAAE,KAAK,EAAE,IAAI,EAAC,CAAC,EAArB,CAAqB,CAAC,CAAC,CAAC;gBAChF,OAAK,CAAC,IAAI,OAAV,OAAK,EAAS,MAAM,CAAC,IAAI,CAAC,SAAS,CAAC,OAAO,CAAC,CAAC,GAAG,CAAC,UAAA,IAAI,IAAI,OAAA,CAAC,EAAC,UAAI,EAAE,MAAM,EAAE,IAAI,EAAC,CAAC,EAAtB,CAAsB,CAAC,CAAC,CAAC;YACpF,CAAC;QACH,CAAC,CAAC,CAAC;QAEH,yDAAyD;QACzD,OAAK,GAAG,SAAS,CAAC,OAAK,CAAC,CAAC;QAEzB,qFAAqF;QACrF,UAAU;QACV,UAAU,CAAC,IAAI,OAAf,UAAU,EAAS,OAAO,CAAC,OAAK,CAAC,GAAG,CAAC,YAAY,CAAC,CAAC,CAAC,CAAC;IACvD,CAAC;IACD,MAAM,CAAC,UAAU,CAAC;AACpB,CAAC;AAED,mCACI,IAAkB,EAAE,QAAgB,EAAE,IAAe;IACvD,IAAM,IAAI,GAAG,IAAI,eAAe,CAAC,IAAI,CAAC,WAAW,EAAE,QAAQ,CAAC,CAAC;IAC7D,IAAM,YAAY,GAAG,IAAI,CAAC,IAAI,CAAC;IAC/B,EAAE,CAAC,CAAC,YAAY,CAAC,CAAC,CAAC;QACjB,IAAM,OAAO,GACT,IAAI,iBAAiB,CAAC,IAAI,EAAE,QAAQ,EAAE,IAAI,EAAE,cAAM,OAAA,kBAAkB,CAAC,IAAI,EAAE,IAAI,EAAE,KAAK,CAAC,EAArC,CAAqC,CAAC,CAAC;QAC7F,YAAY,CAAC,KAAK,CAAC,OAAO,EAAE,IAAI,CAAC,CAAC;QAClC,EAAE,CAAC,CAAC,CAAC,OAAO,CAAC,MAAM,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC,CAAC;YAC9C,iCAAiC;YACjC,IAAM,WAAS,GAAG,IAAI,eAAe,CAAC,IAAI,CAAC,WAAW,EAAE,QAAQ,EAAE,mBAAmB,CAAC,IAAI,CAAC,CAAC;YAC5F,EAAE,CAAC,CAAC,WAAS,CAAC,IAAI,CAAC,CAAC,CAAC;gBACnB,IAAM,YAAY,GAAG,IAAI,iBAAiB,CACtC,IAAI,EAAE,QAAQ,EAAE,IAAI,EAAE,cAAM,OAAA,kBAAkB,CAAC,IAAI,EAAE,WAAS,EAAE,KAAK,CAAC,EAA1C,CAA0C,CAAC,CAAC;gBAC5E,WAAS,CAAC,IAAI,CAAC,KAAK,CAAC,YAAY,EAAE,IAAI,CAAC,CAAC;gBACzC,MAAM,CAAC,YAAY,CAAC,MAAM,CAAC;YAC7B,CAAC;QACH,CAAC;QACD,MAAM,CAAC,OAAO,CAAC,MAAM,CAAC;IACxB,CAAC;AACH,CAAC;AAED,4BAA4B,IAAkB,EAAE,IAAiB;IAC/D,IAAI,SAAS,GAAG,YAAY,EAAE,CAAC,MAAM,CAAC,UAAA,IAAI,IAAI,OAAA,CAAC,CAAC,IAAI,IAAI,kBAAkB,CAAC,EAA7B,CAA6B,CAAC,CAAC;IAE7E,mDAAmD;IACnD,IAAI,iBAAiB,GACjB,YAAY,CAAC,IAAI,CAAC,CAAC,SAAS,CAAC,GAAG,CAAC,UAAA,QAAQ,IAAI,OAAA,QAAQ,CAAC,OAAO,EAAhB,CAAgB,CAAC,CAAC,MAAM,CAAC,UAAA,IAAI,IAAI,OAAA,CAAC,CAAC,IAAI,EAAN,CAAM,CAAC,CAAC;IAE1F,IAAI,UAAU,GACV,iBAAiB,CAAC,GAAG,CAAa,UAAA,IAAI,IAAI,OAAA,CAAC,EAAC,IAAI,EAAE,WAAW,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAC,CAAC,EAA7C,CAA6C,CAAC,CAAC;IAC7F,IAAI,YAAY,GAAG,SAAS,CAAC,GAAG,CAAa,UAAA,IAAI,IAAI,OAAA,CAAC,EAAC,IAAI,EAAE,SAAS,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAC,CAAC,EAA3C,CAA2C,CAAC,CAAC;IAElG,sCAAsC;IACtC,MAAM,CAAC,YAAY,CAAC,YAAY,CAAC,MAAM,CAAC,UAAU,CAAC,CAAC,CAAC;AACvD,CAAC;AAED,2BAA2B,KAAa,EAAE,QAAgB;IACxD,8BAA8B;IAC9B,IAAM,EAAE,GAAG,qBAAqB,CAAC;IACjC,IAAI,KAA2B,CAAC;IAChC,IAAI,MAAmB,CAAC;IACxB,OAAO,KAAK,GAAG,EAAE,CAAC,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC;QAC9B,IAAI,GAAG,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC;QAC1B,EAAE,CAAC,CAAC,QAAQ,IAAI,KAAK,CAAC,KAAK,IAAI,QAAQ,GAAG,CAAC,KAAK,CAAC,KAAK,GAAG,GAAG,CAAC,CAAC,CAAC,CAAC;YAC9D,MAAM,GAAG,MAAM,CAAC,IAAI,CAAC,cAAc,CAAC;iBACtB,GAAG,CAAa,UAAA,IAAI,IAAI,OAAA,CAAC,EAAC,IAAI,EAAE,QAAQ,EAAE,IAAI,EAAE,MAAI,IAAI,MAAG,EAAE,IAAI,EAAE,IAAI,EAAC,CAAC,EAAjD,CAAiD,CAAC,CAAC;YACzF,KAAK,CAAC;QACR,CAAC;IACH,CAAC;IACD,MAAM,CAAC,MAAM,CAAC;AAChB,CAAC;AAED,kCAAkC,IAAkB,EAAE,QAAgB;IACpE,gDAAgD;IAChD,IAAM,YAAY,GAAG,IAAI,eAAe,CAAC,IAAI,CAAC,WAAW,EAAE,QAAQ,CAAC,CAAC;IACrE,IAAM,YAAY,GAAG,YAAY,CAAC,IAAI,CAAC;IACvC,EAAE,CAAC,CAAC,YAAY,CAAC,CAAC,CAAC;QACjB,IAAI,OAAO,GAAG,IAAI,iBAAiB,CAC/B,IAAI,EAAE,QAAQ,EAAE,SAAS,EAAE,cAAM,OAAA,kBAAkB,CAAC,IAAI,EAAE,YAAY,EAAE,KAAK,CAAC,EAA7C,CAA6C,CAAC,CAAC;QACpF,YAAY,CAAC,KAAK,CAAC,OAAO,EAAE,IAAI,CAAC,CAAC;QAClC,MAAM,CAAC,YAAY,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC;IACtC,CAAC;AACH,CAAC;AAED,wFAAwF;AACxF,oFAAoF;AACpF,wFAAwF;AACxF,0FAA0F;AAC1F,2FAA2F;AAC3F,gBAAgB;AAChB,yCAAyC,IAAkB,EAAE,IAAiB;IAC5E,IAAI,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC;IACrB,EAAE,CAAC,CAAC,IAAI,YAAY,IAAI,CAAC,CAAC,CAAC;QACzB,IAAI,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,mCAAmC,CAAC,CAAC;QAClE,yFAAyF;QACzF,sFAAsF;QACtF,EAAE,CAAC,CAAC,KAAK,IAAI,IAAI,CAAC,QAAQ,IAAI,KAAK,CAAC,KAAK,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC,MAAM,GAAG,IAAI,CAAC,UAAU,CAAC,KAAK,CAAC,MAAM,CAAC,CAAC,CAAC;YAC3F,MAAM,CAAC,8BAA8B,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC;QACxD,CAAC;IACH,CAAC;AACH,CAAC;AAED;IAAgC,qCAAmB;IAGjD,2BACY,IAAkB,EAAU,QAAgB,EAAU,IAAgB,EACtE,kBAAsC;QAChD,iBAAO,CAAC;QAFE,SAAI,GAAJ,IAAI,CAAc;QAAU,aAAQ,GAAR,QAAQ,CAAQ;QAAU,SAAI,GAAJ,IAAI,CAAY;QACtE,uBAAkB,GAAlB,kBAAkB,CAAoB;QAEhD,EAAE,CAAC,CAAC,CAAC,kBAAkB,CAAC,CAAC,CAAC;YACxB,IAAI,CAAC,kBAAkB,GAAG,cAAM,OAAA,IAAI,CAAC,QAAQ,CAAC,OAAO,EAArB,CAAqB,CAAC;QACxD,CAAC;IACH,CAAC;IAED,kDAAsB,GAAtB,UAAuB,GAA8B;QACnD,IAAI,CAAC,yBAAyB,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC;IAC5C,CAAC;IAED,gDAAoB,GAApB,UAAqB,GAA4B;QAC/C,IAAI,CAAC,yBAAyB,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC;IAC5C,CAAC;IAED,sCAAU,GAAV,UAAW,GAAkB,IAAU,IAAI,CAAC,yBAAyB,CAAC,GAAG,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC;IAErF,wCAAY,GAAZ,UAAa,GAAe;QAA5B,iBAwEC;QAvEC,EAAE,CAAC,CAAC,IAAI,CAAC,IAAI,IAAI,YAAY,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,UAAU,CAAC,oBAAoB,CAAC,CAAC,CAAC,CAAC;YAC5F,sFAAsF;YACtF,6BAA6B;YAC7B,eAAe;YAEf,IAAM,KAAG,GAAG,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,oBAAoB,CAAC,MAAM,CAAC,CAAC;YAE/D,oBAAoB;YACpB,IAAM,YAAY,GAAG,YAAY,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;YAC7C,IAAM,SAAS,GAAG,YAAY,CAAC,SAAS,CAAC;YACzC,IAAM,UAAQ,GACV,SAAS,CAAC,MAAM,CAAC,UAAA,CAAC,IAAI,OAAA,CAAC,CAAC,KAAK,CAAC,IAAI,CAAC,UAAC,IAAI,EAAE,CAAC,IAAK,OAAA,CAAC,GAAG,CAAC,IAAI,CAAC,IAAI,IAAI,IAAI,KAAG,EAAzB,CAAyB,CAAC,EAApD,CAAoD,CAAC,CAAC,CAAC,CAAC,CAAC;YAEnF,IAAM,qBAAqB,GACvB,IAAI,CAAC,IAAI,CAAC,gBAAgB,CAAC,qBAAqB,CAAC,KAAG,EAAE,IAAI,CAAC,IAAI,CAAC,KAAK,EAAE,IAAI,CAAC,CAAC;YAEjF,uDAAuD;YACvD,IAAM,uBAAqB,GAAG,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,MAAM,GAAG,CAAC,CAAC;YACnF,IAAM,QAAQ,GAAG,qBAAqB,CAAC,gBAAgB,CAAC;YACxD,IAAM,OAAO,GACT,QAAQ,CAAC,IAAI,CACT,UAAA,OAAO,IAAI,OAAA,MAAM,CAAC,uBAAqB,EAAE,OAAO,CAAC,IAAI,EAAE,eAAe,CAAC,IAAI,CAAC,EAAjE,CAAiE,CAAC;gBACjF,QAAQ,CAAC,IAAI,CAAC,UAAA,OAAO,IAAI,OAAA,MAAM,CAAC,uBAAqB,EAAE,OAAO,CAAC,IAAI,CAAC,EAA3C,CAA2C,CAAC,CAAC;YAE1E,IAAM,cAAc,GAAG;gBACrB,IAAI,IAAI,GAAa,EAAE,CAAC;gBACxB,EAAE,CAAC,CAAC,UAAQ,CAAC,CAAC,CAAC;oBACb,IAAM,SAAS,GAAG,UAAQ,CAAC,KAAK,CAAC,MAAM,CAAC,UAAC,CAAC,EAAE,CAAC,IAAK,OAAA,CAAC,GAAG,CAAC,IAAI,CAAC,EAAV,CAAU,CAAC,CAAC;oBAC9D,IAAI,GAAG,SAAS,CAAC,MAAM,CAAC,UAAA,IAAI,IAAI,OAAA,IAAI,CAAC,UAAU,CAAC,KAAG,CAAC,IAAI,IAAI,IAAI,KAAG,EAAnC,CAAmC,CAAC;yBACxD,GAAG,CAAC,UAAA,IAAI,IAAI,OAAA,SAAS,CAAC,IAAI,CAAC,MAAM,CAAC,KAAG,CAAC,MAAM,CAAC,CAAC,EAAlC,CAAkC,CAAC,CAAC;gBAC9D,CAAC;gBACD,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;gBACjB,KAAI,CAAC,MAAM,GAAG,IAAI,CAAC,GAAG,CAAC,UAAA,GAAG,IAAI,OAAY,EAAC,IAAI,EAAE,KAAK,EAAE,IAAI,EAAE,GAAG,EAAE,IAAI,EAAE,GAAG,EAAC,EAA/C,CAA+C,CAAC,CAAC;YACjF,CAAC,CAAC;YAEF,EAAE,CAAC,CAAC,CAAC,OAAO,IAAI,CAAC,OAAO,CAAC,GAAG,IAAI,KAAG,IAAI,CAAC,OAAO,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC;gBAC5D,mFAAmF;gBACnF,YAAY;gBACZ,cAAc,EAAE,CAAC;YACnB,CAAC;YAAC,IAAI,CAAC,EAAE,CAAC,CAAC,OAAO,CAAC,QAAQ,CAAC,CAAC,CAAC;gBAC5B,IAAM,aAAa,GAAG,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC;gBACnD,IAAI,CAAC,MAAM,GAAG,EAAE,CAAC;gBACjB,EAAE,CAAC,CAAC,aAAa,IAAI,CAAC,IAAI,uBAAqB,IAAI,aAAa,CAAC,CAAC,CAAC;oBACjE,qFAAqF;oBACrF,uCAAuC;oBACvC,IAAM,iBAAiB,GAAG,YAAY,CAAC,GAAG,CAAC,GAAG,CAAC,UAAQ,CAAC,CAAC;oBACzD,IAAM,YAAY,GACd,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,kBAAkB,CAAC,iBAAiB,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;oBAClF,EAAE,CAAC,CAAC,YAAY,CAAC,CAAC,CAAC;wBACjB,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC,oBAAoB,CAAC,YAAY,CAAC,MAAM,EAAE,CAAC,CAAC;oBACjE,CAAC;gBACH,CAAC;gBAAC,IAAI,CAAC,EAAE,CAAC,CAAC,OAAO,CAAC,GAAG,IAAI,uBAAqB,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,MAAM,GAAG,KAAG,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC;oBACrF,cAAc,EAAE,CAAC;gBACnB,CAAC;YACH,CAAC;YAAC,IAAI,CAAC,CAAC;gBACN,uFAAuF;gBACvF,yBAAyB;gBACzB,EAAE,CAAC,CAAC,CAAC,OAAO,CAAC,UAAU,IAAI,MAAM,CAAC,uBAAqB,EAAE,OAAO,CAAC,UAAU,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;oBAClF,CAAC,OAAO,CAAC,GAAG;wBACX,uBAAqB,GAAG,OAAO,CAAC,IAAI,CAAC,KAAK,GAAG,CAAC,OAAO,CAAC,GAAG,CAAC,MAAM,GAAG,KAAG,CAAC,MAAM,CAAC,CAAC;oBAChF,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC,CAAC;oBACjB,IAAM,IAAI,GAAG,IAAI,SAAS,CAAC,CAAC,EAAE,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,CAAC;oBACtD,IAAI,CAAC,yBAAyB,CAC1B,OAAO,CAAC,UAAU,GAAG,OAAO,CAAC,UAAU,CAAC,GAAG;wBACtB,IAAI,YAAY,CAAC,IAAI,EAAE,IAAI,gBAAgB,CAAC,IAAI,CAAC,EAAE,EAAE,CAAC,EAC3E,uBAAqB,CAAC,CAAC;gBAC7B,CAAC;gBAAC,IAAI,CAAC,CAAC;oBACN,cAAc,EAAE,CAAC;gBACnB,CAAC;YACH,CAAC;QACH,CAAC;IACH,CAAC;IAED,0CAAc,GAAd,UAAe,GAAiB;QAC9B,IAAM,kBAAkB,GAAG,IAAI,CAAC,QAAQ,GAAG,GAAG,CAAC,UAAU,CAAC,KAAK,CAAC,MAAM,CAAC;QACvE,EAAE,CAAC,CAAC,MAAM,CAAC,kBAAkB,EAAE,GAAG,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;YAC/C,IAAM,WAAW,GAAG,wBAAwB,CACxC,IAAI,CAAC,kBAAkB,EAAE,EAAE,GAAG,CAAC,KAAK,EAAE,kBAAkB,EAAE,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC;YACxF,EAAE,CAAC,CAAC,WAAW,CAAC,CAAC,CAAC;gBAChB,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC,oBAAoB,CAAC,WAAW,CAAC,CAAC;YACvD,CAAC;QACH,CAAC;IACH,CAAC;IAEO,qDAAyB,GAAjC,UAAkC,KAAU,EAAE,QAAiB;QAC7D,IAAM,OAAO,GAAG,wBAAwB,CACpC,IAAI,CAAC,kBAAkB,EAAE,EAAE,KAAK,EAAE,QAAQ,IAAI,IAAI,GAAG,IAAI,CAAC,sBAAsB,GAAG,QAAQ,EAC3F,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC;QAC9B,EAAE,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC;YACZ,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC,oBAAoB,CAAC,OAAO,CAAC,CAAC;QACnD,CAAC;IACH,CAAC;IAEO,gDAAoB,GAA5B,UAA6B,OAAiB;QAC5C,MAAM,CAAC,OAAO,CAAC,MAAM,CAAC,UAAA,CAAC,IAAI,OAAA,CAAC,CAAC,CAAC,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,MAAM,EAApC,CAAoC,CAAC;aAC3D,GAAG,CAAC,UAAA,MAAM,IAAI,OAAY,EAAC,IAAI,EAAE,MAAM,CAAC,IAAI,EAAE,IAAI,EAAE,MAAM,CAAC,IAAI,EAAE,IAAI,EAAE,MAAM,CAAC,IAAI,EAAC,EAArE,CAAqE,CAAC,CAAC;IAC5F,CAAC;IAED,sBAAY,qDAAsB;aAAlC;YACE,MAAM,CAAC,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,MAAM,GAAG,CAAC,CAAC;QAC9D,CAAC;;;OAAA;IACH,wBAAC;AAAD,CAAC,AA5HD,CAAgC,mBAAmB,GA4HlD;AAID,uBAAuB,QAAwB,EAAE,IAAU;IACzD,MAAM,CAAC,QAAQ,CAAC,MAAM,CAAC,SAAS,CAAC,IAAI,CAAC,KAAK,EAAE,IAAI,CAAC,GAAG,CAAC,CAAC;AACzD,CAAC;AAED,oBAAoB,IAAc;IAChC,IAAI,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC;IACrB,EAAE,CAAC,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC;QAChB,IAAI,GAAG,YAAY,CAAC,IAAI,EAAE,QAAQ,CAAC,CAAC;QACpC,IAAI,GAAG,YAAY,CAAC,IAAI,EAAE,SAAS,CAAC,CAAC;IACvC,CAAC;IACD,IAAI,MAAM,GAAG,CAAC,IAAI,CAAC,CAAC;IACpB,EAAE,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC;QACf,MAAM,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC;QACpB,MAAM,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;IACnB,CAAC;IACD,EAAE,CAAC,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC;QAChB,MAAM,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC;QACpB,MAAM,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;IACnB,CAAC;IACD,EAAE,CAAC,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAC;QAClB,MAAM,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC;IACtB,CAAC;IACD,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;AACzB,CAAC;AAED,IAAM,YAAY,GAAG,yBAAyB,CAAC;AAC/C,kCAAkC,OAAgB;IAChD,IAAM,WAAW,GAAG,IAAI,WAAW,EAAE,CAAC;IACtC,IAAI,UAAU,GAAG,WAAW,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC;IAE9C,WAAW,CAAC,UAAU,CAAC,UAAU,CAAC,CAAC;IAEnC,GAAG,CAAC,CAAa,UAAa,EAAb,KAAA,OAAO,CAAC,KAAK,EAAb,cAAa,EAAb,IAAa,CAAC;QAA1B,IAAI,IAAI,SAAA;QACX,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,YAAY,CAAC,CAAC,CAAC,CAAC;YACnC,IAAA,2BAA8C,EAAzC,SAAC,EAAE,oBAAY,CAA2B;YAC/C,WAAW,CAAC,YAAY,CAAC,YAAY,EAAE,IAAI,CAAC,KAAK,CAAC,CAAC;YACnD,EAAE,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,WAAW,EAAE,IAAI,OAAO,CAAC,CAAC,CAAC;gBACvC,IAAM,OAAO,GAAG,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC;gBACxC,OAAO,CAAC,OAAO,CAAC,UAAA,SAAS,IAAI,OAAA,WAAW,CAAC,YAAY,CAAC,SAAS,CAAC,EAAnC,CAAmC,CAAC,CAAC;YACpE,CAAC;QACH,CAAC;KACF;IACD,MAAM,CAAC,WAAW,CAAC;AACrB,CAAC;AAED,mBAAmB,KAAiB;IAClC,IAAI,WAAW,GAAG,IAAI,GAAG,EAAoB,CAAC;IAC9C,IAAI,SAAS,GAAG,IAAI,GAAG,EAAoB,CAAC;IAC5C,IAAI,MAAM,GAAe,EAAE,CAAC;IAC5B,KAAK,CAAC,OAAO,CAAC,UAAA,IAAI;QAChB,EAAE,CAAC,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAC;YAClB,MAAM,CAAC,IAAI,CAAC;QACd,CAAC;QACD,EAAE,CAAC,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAC;YAClB,IAAI,SAAS,GAAG,SAAS,CAAC,GAAG,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;YACzC,EAAE,CAAC,CAAC,CAAC,SAAS,CAAC,CAAC,CAAC;gBACf,MAAM,CAAC,IAAI,CAAC,EAAC,IAAI,EAAE,IAAI,CAAC,IAAI,EAAE,QAAQ,EAAE,IAAI,EAAC,CAAC,CAAC;gBAC/C,SAAS,CAAC,GAAG,CAAC,IAAI,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC;YACjC,CAAC;QACH,CAAC;QACD,EAAE,CAAC,CAAC,IAAI,CAAC,KAAK,IAAI,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC;YAC9B,IAAI,SAAS,GAAG,WAAW,CAAC,GAAG,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;YAC3C,EAAE,CAAC,CAAC,SAAS,CAAC,CAAC,CAAC;gBACd,SAAS,CAAC,KAAK,GAAG,SAAS,CAAC,KAAK,IAAI,IAAI,CAAC,KAAK,CAAC;gBAChD,SAAS,CAAC,MAAM,GAAG,SAAS,CAAC,MAAM,IAAI,IAAI,CAAC,MAAM,CAAC;YACrD,CAAC;YAAC,IAAI,CAAC,CAAC;gBACN,IAAI,SAAS,GAAa,EAAC,IAAI,EAAE,IAAI,CAAC,IAAI,EAAC,CAAC;gBAC5C,EAAE,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC;oBAAC,SAAS,CAAC,KAAK,GAAG,IAAI,CAAC;gBACvC,EAAE,CAAC,CAAC,IAAI,CAAC,MAAM,CAAC;oBAAC,SAAS,CAAC,MAAM,GAAG,IAAI,CAAC;gBACzC,MAAM,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;gBACvB,WAAW,CAAC,GAAG,CAAC,IAAI,CAAC,IAAI,EAAE,SAAS,CAAC,CAAC;YACxC,CAAC;QACH,CAAC;IACH,CAAC,CAAC,CAAC;IACH,MAAM,CAAC,MAAM,CAAC;AAChB,CAAC;AAED,sBAAsB,IAAc;IAClC,EAAE,CAAC,CAAC,IAAI,CAAC,KAAK,IAAI,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC;QAC9B,MAAM,CAAC;YACL,IAAI,EAAE,EAAC,IAAI,EAAE,IAAI,CAAC,IAAI,EAAE,KAAK,EAAE,IAAI,EAAE,MAAM,EAAE,KAAK,EAAC;YACnD,EAAC,IAAI,EAAE,IAAI,CAAC,IAAI,EAAE,KAAK,EAAE,KAAK,EAAE,MAAM,EAAE,IAAI,EAAC;SAC9C,CAAC;IACJ,CAAC;IACD,MAAM,CAAC,CAAC,IAAI,CAAC,CAAC;AAChB,CAAC;AAED,mBAAmB,IAAY;IAC7B,MAAM,CAAC,IAAI,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,WAAW,EAAE,GAAG,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC;AAC1D,CAAC","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {AST, ImplicitReceiver, ParseSpan, PropertyRead} from '@angular/compiler/src/expression_parser/ast';\nimport {Attribute, Element, Node as HtmlAst, Text} from '@angular/compiler/src/ml_parser/ast';\nimport {getHtmlTagDefinition} from '@angular/compiler/src/ml_parser/html_tags';\nimport {NAMED_ENTITIES, TagContentType, splitNsName} from '@angular/compiler/src/ml_parser/tags';\nimport {CssSelector, SelectorMatcher} from '@angular/compiler/src/selector';\nimport {AttrAst, BoundDirectivePropertyAst, BoundElementPropertyAst, BoundEventAst, BoundTextAst, DirectiveAst, ElementAst, EmbeddedTemplateAst, NgContentAst, ReferenceAst, TemplateAst, TemplateAstVisitor, TextAst, VariableAst, templateVisitAll} from '@angular/compiler/src/template_parser/template_ast';\n\nimport {AstResult, AttrInfo, SelectorInfo, TemplateInfo} from './common';\nimport {getExpressionCompletions, getExpressionScope} from './expressions';\nimport {attributeNames, elementNames, eventNames, propertyNames} from './html_info';\nimport {HtmlAstPath} from './html_path';\nimport {NullTemplateVisitor, TemplateAstChildVisitor, TemplateAstPath} from './template_path';\nimport {BuiltinType, Completion, Completions, Span, Symbol, SymbolDeclaration, SymbolTable, TemplateSource} from './types';\nimport {flatten, getSelectors, hasTemplateReference, inSpan, removeSuffix, spanOf, uniqueByName} from './utils';\n\nconst TEMPLATE_ATTR_PREFIX = '*';\n\nconst hiddenHtmlElements = {\n  html: true,\n  script: true,\n  noscript: true,\n  base: true,\n  body: true,\n  title: true,\n  head: true,\n  link: true,\n};\n\nexport function getTemplateCompletions(templateInfo: TemplateInfo): Completions {\n  let result: Completions = undefined;\n  let {htmlAst, templateAst, template} = templateInfo;\n  // The templateNode starts at the delimiter character so we add 1 to skip it.\n  let templatePosition = templateInfo.position - template.span.start;\n  let path = new HtmlAstPath(htmlAst, templatePosition);\n  let mostSpecific = path.tail;\n  if (path.empty) {\n    result = elementCompletions(templateInfo, path);\n  } else {\n    let astPosition = templatePosition - mostSpecific.sourceSpan.start.offset;\n    mostSpecific.visit(\n        {\n          visitElement(ast) {\n            let startTagSpan = spanOf(ast.sourceSpan);\n            let tagLen = ast.name.length;\n            if (templatePosition <=\n                startTagSpan.start + tagLen + 1 /* 1 for the opening angle bracked */) {\n              // If we are in the tag then return the element completions.\n              result = elementCompletions(templateInfo, path);\n            } else if (templatePosition < startTagSpan.end) {\n              // We are in the attribute section of the element (but not in an attribute).\n              // Return the attribute completions.\n              result = attributeCompletions(templateInfo, path);\n            }\n          },\n          visitAttribute(ast) {\n            if (!ast.valueSpan || !inSpan(templatePosition, spanOf(ast.valueSpan))) {\n              // We are in the name of an attribute. Show attribute completions.\n              result = attributeCompletions(templateInfo, path);\n            } else if (ast.valueSpan && inSpan(templatePosition, spanOf(ast.valueSpan))) {\n              result = attributeValueCompletions(templateInfo, templatePosition, ast);\n            }\n          },\n          visitText(ast) {\n            // Check if we are in a entity.\n            result = entityCompletions(getSourceText(template, spanOf(ast)), astPosition);\n            if (result) return result;\n            result = interpolationCompletions(templateInfo, templatePosition);\n            if (result) return result;\n            let element = path.first(Element);\n            if (element) {\n              let definition = getHtmlTagDefinition(element.name);\n              if (definition.contentType === TagContentType.PARSABLE_DATA) {\n                result = voidElementAttributeCompletions(templateInfo, path);\n                if (!result) {\n                  // If the element can hold content Show element completions.\n                  result = elementCompletions(templateInfo, path);\n                }\n              }\n            } else {\n              // If no element container, implies parsable data so show elements.\n              result = voidElementAttributeCompletions(templateInfo, path);\n              if (!result) {\n                result = elementCompletions(templateInfo, path);\n              }\n            }\n          },\n          visitComment(ast) {},\n          visitExpansion(ast) {},\n          visitExpansionCase(ast) {}\n        },\n        null);\n  }\n  return result;\n}\n\nfunction attributeCompletions(info: TemplateInfo, path: HtmlAstPath): Completions {\n  let item = path.tail instanceof Element ? path.tail : path.parentOf(path.tail);\n  if (item instanceof Element) {\n    return attributeCompletionsForElement(info, item.name, item);\n  }\n  return undefined;\n}\n\nfunction attributeCompletionsForElement(\n    info: TemplateInfo, elementName: string, element?: Element): Completions {\n  const attributes = getAttributeInfosForElement(info, elementName, element);\n\n  // Map all the attributes to a completion\n  return attributes.map<Completion>(attr => ({\n                                      kind: attr.fromHtml ? 'html attribute' : 'attribute',\n                                      name: nameOfAttr(attr),\n                                      sort: attr.name\n                                    }));\n}\n\nfunction getAttributeInfosForElement(\n    info: TemplateInfo, elementName: string, element?: Element): AttrInfo[] {\n  let attributes: AttrInfo[] = [];\n\n  // Add html attributes\n  let htmlAttributes = attributeNames(elementName) || [];\n  if (htmlAttributes) {\n    attributes.push(...htmlAttributes.map<AttrInfo>(name => ({name, fromHtml: true})));\n  }\n\n  // Add html properties\n  let htmlProperties = propertyNames(elementName);\n  if (htmlProperties) {\n    attributes.push(...htmlProperties.map<AttrInfo>(name => ({name, input: true})));\n  }\n\n  // Add html events\n  let htmlEvents = eventNames(elementName);\n  if (htmlEvents) {\n    attributes.push(...htmlEvents.map<AttrInfo>(name => ({name, output: true})));\n  }\n\n  let {selectors, map: selectorMap} = getSelectors(info);\n  if (selectors && selectors.length) {\n    // All the attributes that are selectable should be shown.\n    const applicableSelectors =\n        selectors.filter(selector => !selector.element || selector.element == elementName);\n    const selectorAndAttributeNames =\n        applicableSelectors.map(selector => ({selector, attrs: selector.attrs.filter(a => !!a)}));\n    let attrs = flatten(selectorAndAttributeNames.map<AttrInfo[]>(selectorAndAttr => {\n      const directive = selectorMap.get(selectorAndAttr.selector);\n      const result = selectorAndAttr.attrs.map<AttrInfo>(\n          name => ({name, input: name in directive.inputs, output: name in directive.outputs}));\n      return result;\n    }));\n\n    // Add template attribute if a directive contains a template reference\n    selectorAndAttributeNames.forEach(selectorAndAttr => {\n      const selector = selectorAndAttr.selector;\n      const directive = selectorMap.get(selector);\n      if (directive && hasTemplateReference(directive.type) && selector.attrs.length &&\n          selector.attrs[0]) {\n        attrs.push({name: selector.attrs[0], template: true});\n      }\n    });\n\n    // All input and output properties of the matching directives should be added.\n    let elementSelector = element ?\n        createElementCssSelector(element) :\n        createElementCssSelector(new Element(elementName, [], [], undefined, undefined, undefined));\n\n    let matcher = new SelectorMatcher();\n    matcher.addSelectables(selectors);\n    matcher.match(elementSelector, selector => {\n      let directive = selectorMap.get(selector);\n      if (directive) {\n        attrs.push(...Object.keys(directive.inputs).map(name => ({name, input: true})));\n        attrs.push(...Object.keys(directive.outputs).map(name => ({name, output: true})));\n      }\n    });\n\n    // If a name shows up twice, fold it into a single value.\n    attrs = foldAttrs(attrs);\n\n    // Now expand them back out to ensure that input/output shows up as well as input and\n    // output.\n    attributes.push(...flatten(attrs.map(expandedAttr)));\n  }\n  return attributes;\n}\n\nfunction attributeValueCompletions(\n    info: TemplateInfo, position: number, attr: Attribute): Completions {\n  const path = new TemplateAstPath(info.templateAst, position);\n  const mostSpecific = path.tail;\n  if (mostSpecific) {\n    const visitor =\n        new ExpressionVisitor(info, position, attr, () => getExpressionScope(info, path, false));\n    mostSpecific.visit(visitor, null);\n    if (!visitor.result || !visitor.result.length) {\n      // Try allwoing widening the path\n      const widerPath = new TemplateAstPath(info.templateAst, position, /* allowWidening */ true);\n      if (widerPath.tail) {\n        const widerVisitor = new ExpressionVisitor(\n            info, position, attr, () => getExpressionScope(info, widerPath, false));\n        widerPath.tail.visit(widerVisitor, null);\n        return widerVisitor.result;\n      }\n    }\n    return visitor.result;\n  }\n}\n\nfunction elementCompletions(info: TemplateInfo, path: HtmlAstPath): Completions {\n  let htmlNames = elementNames().filter(name => !(name in hiddenHtmlElements));\n\n  // Collect the elements referenced by the selectors\n  let directiveElements =\n      getSelectors(info).selectors.map(selector => selector.element).filter(name => !!name);\n\n  let components =\n      directiveElements.map<Completion>(name => ({kind: 'component', name: name, sort: name}));\n  let htmlElements = htmlNames.map<Completion>(name => ({kind: 'element', name: name, sort: name}));\n\n  // Return components and html elements\n  return uniqueByName(htmlElements.concat(components));\n}\n\nfunction entityCompletions(value: string, position: number): Completions {\n  // Look for entity completions\n  const re = /&[A-Za-z]*;?(?!\\d)/g;\n  let found: RegExpExecArray|null;\n  let result: Completions;\n  while (found = re.exec(value)) {\n    let len = found[0].length;\n    if (position >= found.index && position < (found.index + len)) {\n      result = Object.keys(NAMED_ENTITIES)\n                   .map<Completion>(name => ({kind: 'entity', name: `&${name};`, sort: name}));\n      break;\n    }\n  }\n  return result;\n}\n\nfunction interpolationCompletions(info: TemplateInfo, position: number): Completions {\n  // Look for an interpolation in at the position.\n  const templatePath = new TemplateAstPath(info.templateAst, position);\n  const mostSpecific = templatePath.tail;\n  if (mostSpecific) {\n    let visitor = new ExpressionVisitor(\n        info, position, undefined, () => getExpressionScope(info, templatePath, false));\n    mostSpecific.visit(visitor, null);\n    return uniqueByName(visitor.result);\n  }\n}\n\n// There is a special case of HTML where text that contains a unclosed tag is treated as\n// text. For exaple '<h1> Some <a text </h1>' produces a text nodes inside of the H1\n// element \"Some <a text\". We, however, want to treat this as if the user was requesting\n// the attributes of an \"a\" element, not requesting completion in the a text element. This\n// code checks for this case and returns element completions if it is detected or undefined\n// if it is not.\nfunction voidElementAttributeCompletions(info: TemplateInfo, path: HtmlAstPath): Completions {\n  let tail = path.tail;\n  if (tail instanceof Text) {\n    let match = tail.value.match(/<(\\w(\\w|\\d|-)*:)?(\\w(\\w|\\d|-)*)\\s/);\n    // The position must be after the match, otherwise we are still in a place where elements\n    // are expected (such as `<|a` or `<a|`; we only want attributes for `<a |` or after).\n    if (match && path.position >= match.index + match[0].length + tail.sourceSpan.start.offset) {\n      return attributeCompletionsForElement(info, match[3]);\n    }\n  }\n}\n\nclass ExpressionVisitor extends NullTemplateVisitor {\n  result: Completions;\n\n  constructor(\n      private info: TemplateInfo, private position: number, private attr?: Attribute,\n      private getExpressionScope?: () => SymbolTable) {\n    super();\n    if (!getExpressionScope) {\n      this.getExpressionScope = () => info.template.members;\n    }\n  }\n\n  visitDirectiveProperty(ast: BoundDirectivePropertyAst): void {\n    this.attributeValueCompletions(ast.value);\n  }\n\n  visitElementProperty(ast: BoundElementPropertyAst): void {\n    this.attributeValueCompletions(ast.value);\n  }\n\n  visitEvent(ast: BoundEventAst): void { this.attributeValueCompletions(ast.handler); }\n\n  visitElement(ast: ElementAst): void {\n    if (this.attr && getSelectors(this.info) && this.attr.name.startsWith(TEMPLATE_ATTR_PREFIX)) {\n      // The value is a template expression but the expression AST was not produced when the\n      // TemplateAst was produce so\n      // do that now.\n\n      const key = this.attr.name.substr(TEMPLATE_ATTR_PREFIX.length);\n\n      // Find the selector\n      const selectorInfo = getSelectors(this.info);\n      const selectors = selectorInfo.selectors;\n      const selector =\n          selectors.filter(s => s.attrs.some((attr, i) => i % 2 == 0 && attr == key))[0];\n\n      const templateBindingResult =\n          this.info.expressionParser.parseTemplateBindings(key, this.attr.value, null);\n\n      // find the template binding that contains the position\n      const valueRelativePosition = this.position - this.attr.valueSpan.start.offset - 1;\n      const bindings = templateBindingResult.templateBindings;\n      const binding =\n          bindings.find(\n              binding => inSpan(valueRelativePosition, binding.span, /* exclusive */ true)) ||\n          bindings.find(binding => inSpan(valueRelativePosition, binding.span));\n\n      const keyCompletions = () => {\n        let keys: string[] = [];\n        if (selector) {\n          const attrNames = selector.attrs.filter((_, i) => i % 2 == 0);\n          keys = attrNames.filter(name => name.startsWith(key) && name != key)\n                     .map(name => lowerName(name.substr(key.length)));\n        }\n        keys.push('let');\n        this.result = keys.map(key => <Completion>{kind: 'key', name: key, sort: key});\n      };\n\n      if (!binding || (binding.key == key && !binding.expression)) {\n        // We are in the root binding. We should return `let` and keys that are left in the\n        // selector.\n        keyCompletions();\n      } else if (binding.keyIsVar) {\n        const equalLocation = this.attr.value.indexOf('=');\n        this.result = [];\n        if (equalLocation >= 0 && valueRelativePosition >= equalLocation) {\n          // We are after the '=' in a let clause. The valid values here are the members of the\n          // template reference's type parameter.\n          const directiveMetadata = selectorInfo.map.get(selector);\n          const contextTable =\n              this.info.template.query.getTemplateContext(directiveMetadata.type.reference);\n          if (contextTable) {\n            this.result = this.symbolsToCompletions(contextTable.values());\n          }\n        } else if (binding.key && valueRelativePosition <= (binding.key.length - key.length)) {\n          keyCompletions();\n        }\n      } else {\n        // If the position is in the expression or after the key or there is no key, return the\n        // expression completions\n        if ((binding.expression && inSpan(valueRelativePosition, binding.expression.ast.span)) ||\n            (binding.key &&\n             valueRelativePosition > binding.span.start + (binding.key.length - key.length)) ||\n            !binding.key) {\n          const span = new ParseSpan(0, this.attr.value.length);\n          this.attributeValueCompletions(\n              binding.expression ? binding.expression.ast :\n                                   new PropertyRead(span, new ImplicitReceiver(span), ''),\n              valueRelativePosition);\n        } else {\n          keyCompletions();\n        }\n      }\n    }\n  }\n\n  visitBoundText(ast: BoundTextAst) {\n    const expressionPosition = this.position - ast.sourceSpan.start.offset;\n    if (inSpan(expressionPosition, ast.value.span)) {\n      const completions = getExpressionCompletions(\n          this.getExpressionScope(), ast.value, expressionPosition, this.info.template.query);\n      if (completions) {\n        this.result = this.symbolsToCompletions(completions);\n      }\n    }\n  }\n\n  private attributeValueCompletions(value: AST, position?: number) {\n    const symbols = getExpressionCompletions(\n        this.getExpressionScope(), value, position == null ? this.attributeValuePosition : position,\n        this.info.template.query);\n    if (symbols) {\n      this.result = this.symbolsToCompletions(symbols);\n    }\n  }\n\n  private symbolsToCompletions(symbols: Symbol[]): Completions {\n    return symbols.filter(s => !s.name.startsWith('__') && s.public)\n        .map(symbol => <Completion>{kind: symbol.kind, name: symbol.name, sort: symbol.name});\n  }\n\n  private get attributeValuePosition() {\n    return this.position - this.attr.valueSpan.start.offset - 1;\n  }\n}\n\n\n\nfunction getSourceText(template: TemplateSource, span: Span): string {\n  return template.source.substring(span.start, span.end);\n}\n\nfunction nameOfAttr(attr: AttrInfo): string {\n  let name = attr.name;\n  if (attr.output) {\n    name = removeSuffix(name, 'Events');\n    name = removeSuffix(name, 'Changed');\n  }\n  let result = [name];\n  if (attr.input) {\n    result.unshift('[');\n    result.push(']');\n  }\n  if (attr.output) {\n    result.unshift('(');\n    result.push(')');\n  }\n  if (attr.template) {\n    result.unshift('*');\n  }\n  return result.join('');\n}\n\nconst templateAttr = /^(\\w+:)?(template$|^\\*)/;\nfunction createElementCssSelector(element: Element): CssSelector {\n  const cssSelector = new CssSelector();\n  let elNameNoNs = splitNsName(element.name)[1];\n\n  cssSelector.setElement(elNameNoNs);\n\n  for (let attr of element.attrs) {\n    if (!attr.name.match(templateAttr)) {\n      let [_, attrNameNoNs] = splitNsName(attr.name);\n      cssSelector.addAttribute(attrNameNoNs, attr.value);\n      if (attr.name.toLowerCase() == 'class') {\n        const classes = attr.value.split(/s+/g);\n        classes.forEach(className => cssSelector.addClassName(className));\n      }\n    }\n  }\n  return cssSelector;\n}\n\nfunction foldAttrs(attrs: AttrInfo[]): AttrInfo[] {\n  let inputOutput = new Map<string, AttrInfo>();\n  let templates = new Map<string, AttrInfo>();\n  let result: AttrInfo[] = [];\n  attrs.forEach(attr => {\n    if (attr.fromHtml) {\n      return attr;\n    }\n    if (attr.template) {\n      let duplicate = templates.get(attr.name);\n      if (!duplicate) {\n        result.push({name: attr.name, template: true});\n        templates.set(attr.name, attr);\n      }\n    }\n    if (attr.input || attr.output) {\n      let duplicate = inputOutput.get(attr.name);\n      if (duplicate) {\n        duplicate.input = duplicate.input || attr.input;\n        duplicate.output = duplicate.output || attr.output;\n      } else {\n        let cloneAttr: AttrInfo = {name: attr.name};\n        if (attr.input) cloneAttr.input = true;\n        if (attr.output) cloneAttr.output = true;\n        result.push(cloneAttr);\n        inputOutput.set(attr.name, cloneAttr);\n      }\n    }\n  });\n  return result;\n}\n\nfunction expandedAttr(attr: AttrInfo): AttrInfo[] {\n  if (attr.input && attr.output) {\n    return [\n      attr, {name: attr.name, input: true, output: false},\n      {name: attr.name, input: false, output: true}\n    ];\n  }\n  return [attr];\n}\n\nfunction lowerName(name: string): string {\n  return name && (name[0].toLowerCase() + name.substr(1));\n}\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n"]}